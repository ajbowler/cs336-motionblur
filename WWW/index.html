<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Motion Blur</title>
  </head>
  <body>
    <script type="x-shader/x-vertex" id="vs-motionBlur">
      varying vec2 vUv;

      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        vUv = uv;
      }
    </script>

    <script type="x-shader/x-fragment" id="fs-motionBlur">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform sampler2D tColor;
      uniform vec2 resolution;
      uniform mat4 viewProjectionInverseMatrix;
      uniform mat4 previousViewProjectionMatrix;
      uniform float velocityFactor;

      float unpack_depth(const in vec4 color) {
        return color.r;
      }

     void main() {
        float zOverW = unpack_depth( texture2D( tDiffuse, vUv ) );

        // H is the viewport position at this pixel in the range -1 to 1.  
        vec4 H = vec4( vUv.x * 2. - 1., vUv.y * 2. - 1., zOverW, 1. );  
        // Transform by the view-projection inverse.  
        vec4 D = H * viewProjectionInverseMatrix;
        // Divide by w to get the world position.  
        vec4 worldPos = D / D.w;

        vec4 currentPos = H;  
        // Use the world position, and transform by the previous view-projection matrix.  
        vec4 previousPos = worldPos * previousViewProjectionMatrix;  
        // Convert to nonhomogeneous points [-1,1] by dividing by w.  
        previousPos /= previousPos.w;  
        // Use this frame's position and last frame's to compute the pixel velocity.  
        vec2 velocity = velocityFactor * ( currentPos.xy - previousPos.xy ) * .5;
        //velocity = .01 *  normalize( velocity ); 

        vec4 finalColor = vec4( 0. );
        vec2 offset = vec2( 0. ); 
        float weight = 0.;
        const int samples = 20;
        for( int i = 0; i < samples; i++ ) {  
          offset = velocity * ( float( i ) / ( float( samples ) - 1. ) - .5 );
          vec4 c = texture2D( tColor, vUv + offset );
          finalColor += c;
        }

        // Create the blur by averaging out the colors.
        finalColor /= float( samples );
        gl_FragColor = vec4( finalColor.rgb, 1. );
      }
    </script>

    <script type="x-shader/x-vertex" id="vs-depthRender">
      void main() {
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * mvPosition;
      }
    </script>

    <script type="x-shader/x-fragment" id="fs-depthRender">
      uniform float mNear;
      uniform float mFar;
      uniform float opacity;

      vec4 pack_depth( const in float f ) {
        vec4 color;
        color.r = floor( f / ( 256. * 256. * 256. ) );
        color.g = floor( ( mod( f,  256. * 256. * 256. ) ) / ( 256. * 256. ) );
        color.b = floor( ( mod( f,  256. * 256. ) ) / 256. );
        color.a = floor( mod( f, 256.)  );
        return color / 256.0;
      }

      void main() {
        float depth = gl_FragCoord.z / gl_FragCoord.w;
        float color = 1. - ( depth - mNear ) / ( mFar - mNear );
        gl_FragColor = vec4( color, color, color, 1. );
      }
    </script>

  	<canvas id="theCanvas" width="800" height="600">
    	Please use a browser that supports "canvas"
    </canvas>
    <input type="text" id="increment" placeholder="Increment">
    <button type="button" onclick="getIncrement();">Adjust Increment</button>
    <script src="../lib/three.js"></script>
    <script src="../lib/Group.js"></script>
    <script src="../lib/OBJLoader.js"></script>
    <script src="../lib/MTLLoader.js"></script>
    <script src="../lib/OBJMTLLoader.js"></script>
    <script src="../lib//MaskPass.js"></script>
    <script src="../lib/CopyShader.js"></script>
    <script src="../lib/EffectComposer.js"></script>
    <script src="../lib/ShaderPass.js"></script>
    <script src="../lib/RenderPass.js"></script>
    <script src="../lib/PlaneBufferGeometry.js"></script>
    <script src="index.js"></script>
    <script type="text/javascript">window.onload = start;</script>
  </body>
</html>